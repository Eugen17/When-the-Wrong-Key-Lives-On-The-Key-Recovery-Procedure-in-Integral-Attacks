# Intersect V (given by a basis as tuples of 64-bit words in one big string)
# with W = { v : v_j can be nonzero only when j % 4 in {0,1} }.
# Supports tuple arity 1, 2, or 3. Bit 0 is the LSB of the LAST word.

import re
from typing import List, Tuple

# ===== Paste your whole block here (one tuple per line) =====
INPUT_STR = r"""(0x8000000000000000, 0x0000000000000000, 0x0000000000000000)
(0x4000000000000000, 0x0000000000000000, 0x0000000000000000)
(0x2000000000000000, 0x0000000000000000, 0x0000000000000000)
(0x1000000000000000, 0x0000000000000000, 0x0000000000000000)
(0x0800000000000000, 0x0000000000000000, 0x0000000000000000)
(0x0400000000000000, 0x0000000000000000, 0x0000000000000000)
(0x0200000000000000, 0x0000000000000000, 0x0000000000000000)
(0x0100000000000000, 0x0000000000000000, 0x0000000000000000)
(0x0080000000000000, 0x0000000000000000, 0x0000000000000000)
(0x0040000000000000, 0x0000000000000000, 0x0000000000000000)
(0x0020000000000000, 0x0000000000000000, 0x0000000000000000)
(0x0010000000000000, 0x0000000000000000, 0x0000000000000000)
(0x0008000000000000, 0x0000000000000000, 0x0000000000000000)
(0x0004000000000000, 0x0000000000000000, 0x0000000000000000)
(0x0002000000000000, 0x0000000000000000, 0x0000000000000000)
(0x0000800000000000, 0x0000000000000000, 0x0000000000000000)
(0x0000400000000000, 0x0000000000000000, 0x0000000000000000)
(0x0000200000000000, 0x0000000000000000, 0x0000000000000000)
(0x0000100000000000, 0x0000000000000000, 0x0000000000000000)
(0x0000080000000000, 0x0000000000000000, 0x0000000000000000)
(0x0000040000000000, 0x0000000000000000, 0x0000000000000000)
(0x0000020000000000, 0x0000000000000000, 0x0000000000000000)
(0x0000010000000000, 0x0000000000000000, 0x0000000000000000)
(0x0000008000000000, 0x0000000000000000, 0x0000000000000000)
(0x0000004000000000, 0x0000000000000000, 0x0000000000000000)
(0x0000002000000000, 0x0000000000000000, 0x0000000000000000)
(0x0000001000000000, 0x0000000000000000, 0x0000000000000000)
(0x0000000800000000, 0x0100000000000000, 0x0000000000000000)
(0x0000000400000000, 0x0000000000000000, 0x0000000000000000)
(0x0000000200000000, 0x0000000000000000, 0x0000000000000000)
(0x0000000100000000, 0x0000000000000000, 0x0000000000000000)
(0x0000000080000000, 0x0000000000000000, 0x0000000000000000)
(0x0000000040000000, 0x0000000000000000, 0x0000000000000000)
(0x0000000020000000, 0x0000000000000000, 0x0000000000000000)
(0x0000000010000000, 0x0000000000000000, 0x0000000000000000)
(0x0000000008000000, 0x0000000000000000, 0x0000000000000000)
(0x0000000004000000, 0x0000000000000000, 0x0000000000000000)
(0x0000000002000000, 0x0000000000000000, 0x0000000000000000)
(0x0000000001000000, 0x0000000000000000, 0x0000000000000000)
(0x0000000000800000, 0x0000000000000000, 0x0000000000000000)
(0x0000000000400000, 0x0000000000000000, 0x0000000000000000)
(0x0000000000200000, 0x0000000000000000, 0x0000000000000000)
(0x0000000000100000, 0x0000000000000000, 0x0000000000000000)
(0x0000000000080000, 0x0000000000000000, 0x0000000000000000)
(0x0000000000040000, 0x0000000000000020, 0x0000000000000000)
(0x0000000000020000, 0x0000000000000000, 0x0000000000000000)
(0x0000000000010000, 0x0000000000000000, 0x0000000000000000)
(0x0000000000008000, 0x0000000000000000, 0x0000000000000000)
(0x0000000000004000, 0x0000000000000000, 0x0000000000000000)
(0x0000000000002000, 0x0000000000000000, 0x0000000000000000)
(0x0000000000001000, 0x0000000000000000, 0x0000000000000000)
(0x0000000000000800, 0x0000000000000000, 0x0000000000000000)
(0x0000000000000400, 0x0000000000000000, 0x0000000000000000)
(0x0000000000000200, 0x0000000000000000, 0x0000000000000000)
(0x0000000000000100, 0x0000000000000000, 0x0000000000000000)
(0x0000000000000080, 0x0000000000000000, 0x0000000000000000)
(0x0000000000000040, 0x0000000000000000, 0x0000000000000000)
(0x0000000000000020, 0x0000000000000000, 0x0000000000000000)
(0x0000000000000010, 0x0000000000000000, 0x0000000000000000)
(0x0000000000000008, 0x0000000000000000, 0x0000000000000000)
(0x0000000000000004, 0x0000000000000000, 0x0000000000000000)
(0x0000000000000001, 0x0000000000000000, 0x0000000000000000)
(0x0000000000000000, 0x8000000000000000, 0x0000000000000000)
(0x0000000000000000, 0x4000000000000000, 0x0000000000000000)
(0x0000000000000000, 0x2000000000000000, 0x0000000000000000)
(0x0000000000000000, 0x0800000000000000, 0x0000000000000000)
(0x0000000000000000, 0x0400000000000000, 0x0000000000000000)
(0x0000000000000000, 0x0200000000000000, 0x0000000000000000)
(0x0000000000000000, 0x0100000004000000, 0x0000000000000000)
(0x0000000000000000, 0x0080000000000000, 0x0000000000000000)
(0x0000000000000000, 0x0040000000000000, 0x0000000000000000)
(0x0000000000000000, 0x0020000000000000, 0x0000000000000000)
(0x0000000000000000, 0x0008000000000000, 0x0000000000000000)
(0x0000000000000000, 0x0004000000000000, 0x0000000000000000)
(0x0000000000000000, 0x0002000000000000, 0x0000000000000000)
(0x0000000000000000, 0x0000800000000000, 0x0000000000000100)
(0x0000000000000000, 0x0000400000000000, 0x0000000000000000)
(0x0000000000000000, 0x0000200000000000, 0x0000000000000000)
(0x0000000000000000, 0x0000100000000000, 0x0000000000000000)
(0x0000000000000000, 0x0000080000000000, 0x0000000001000000)
(0x0000000000000000, 0x0000040000000000, 0x0000000000000000)
(0x0000000000000000, 0x0000020000000000, 0x0000000000000000)
(0x0000000000000000, 0x0000010000000000, 0x0000000000000000)
(0x0000000000000000, 0x0000008000000000, 0x0000010000000000)
(0x0000000000000000, 0x0000004000000000, 0x0000000000000000)
(0x0000000000000000, 0x0000002000000000, 0x0000000000000000)
(0x0000000000000000, 0x0000001000000000, 0x0000000000000000)
(0x0000000000000000, 0x0000000800000000, 0x0100000000000000)
(0x0000000000000000, 0x0000000400000000, 0x0000000000000000)
(0x0000000000000000, 0x0000000200000000, 0x0000000000000000)
(0x0000000000000000, 0x0000000100000000, 0x0000000000000000)
(0x0000000000000000, 0x0000000080000000, 0x0000000000000000)
(0x0000000000000000, 0x0000000040000000, 0x0000000000200000)
(0x0000000000000000, 0x0000000020000000, 0x0000000000000000)
(0x0000000000000000, 0x0000000010000000, 0x0000000000000000)
(0x0000000000000000, 0x0000000008000000, 0x0000000000000000)
(0x0000000000000000, 0x0000000004000000, 0x0000002000000000)
(0x0000000000000000, 0x0000000002000000, 0x0000000000000000)
(0x0000000000000000, 0x0000000001000000, 0x0000000000000000)
(0x0000000000000000, 0x0000000000800000, 0x0000000000000000)
(0x0000000000000000, 0x0000000000400020, 0x0000000000000000)
(0x0000000000000000, 0x0000000000200000, 0x0000000000000000)
(0x0000000000000000, 0x0000000000100000, 0x0000000000000000)
(0x0000000000000000, 0x0000000000080000, 0x0000000000000000)
(0x0000000000000000, 0x0000000000040000, 0x0000000000000020)
(0x0000000000000000, 0x0000000000020000, 0x0000000000000000)
(0x0000000000000000, 0x0000000000010000, 0x0000000000000000)
(0x0000000000000000, 0x0000000000008000, 0x0000000000000000)
(0x0000000000000000, 0x0000000000004000, 0x0000000000000000)
(0x0000000000000000, 0x0000000000001000, 0x0000000000000000)
(0x0000000000000000, 0x0000000000000800, 0x0000000000000000)
(0x0000000000000000, 0x0000000000000400, 0x0000000000000000)
(0x0000000000000000, 0x0000000000000100, 0x0000000000000000)
(0x0000000000000000, 0x0000000000000080, 0x0000000000000000)
(0x0000000000000000, 0x0000000000000040, 0x0000000000000000)
(0x0000000000000000, 0x0000000000000020, 0x0020000000000000)
(0x0000000000000000, 0x0000000000000010, 0x0000000000000000)
(0x0000000000000000, 0x0000000000000008, 0x0000000000000000)
(0x0000000000000000, 0x0000000000000004, 0x0000000000000000)
(0x0000000000000000, 0x0000000000000001, 0x0000000000000000)
(0x0000000000000000, 0x0000000000000000, 0x0400000001000000)
(0x0000000000000000, 0x0000000000000000, 0x0100000004000000)
(0x0000000000000000, 0x0000000000000000, 0x0040002000000000)
(0x0000000000000000, 0x0000000000000000, 0x0020000000000040)
(0x0000000000000000, 0x0000000000000000, 0x0000040000000100)
(0x0000000000000000, 0x0000000000000000, 0x0000010000000400)
(0x0000000000000000, 0x0000000000000000, 0x0000004000200000)
(0x0000000000000000, 0x0000000000000000, 0x0000000000400020)
"""

# ===== Parsing (supports arity 1, 2, or 3; accepts 0x... or x...) =====

def parse_tuple_block(s: str) -> List[Tuple[int, ...]]:
    tuples_raw = re.findall(r'\(([^)]*)\)', s)
    if not tuples_raw:
        raise ValueError("No tuples found.")
    parsed: List[Tuple[int, ...]] = []
    for t in tuples_raw:
        toks = re.findall(r'(?:0x|x)[0-9A-Fa-f]+', t)
        toks = [('0' + tok) if tok.startswith('x') else tok for tok in toks]
        if not toks:
            continue
        parsed.append(tuple(int(tok, 16) for tok in toks))
    # Ensure all tuples have same arity
    arities = {len(t) for t in parsed}
    if len(arities) != 1:
        raise ValueError(f"Inconsistent tuple arities found: {sorted(arities)}")
    if next(iter(arities)) not in (1, 2, 3):
        raise ValueError("Only arity 1, 2, or 3 is supported.")
    return parsed

# ===== GF(2) helpers (generic in arity) =====

def bit_at(words: Tuple[int, ...], j: int) -> int:
    """Bit j with bit 0 = LSB of LAST word."""
    k = len(words)
    word_index = k - 1 - (j // 64)
    if word_index < 0 or word_index >= k:
        return 0
    return (words[word_index] >> (j % 64)) & 1

def xor_words(a: Tuple[int, ...], b: Tuple[int, ...]) -> Tuple[int, ...]:
    return tuple(x ^ y for x, y in zip(a, b))

def rref_bitrows(rows: List[int], ncols: int):
    rows = rows[:]
    m, r = len(rows), 0
    pivots: List[int] = []
    for col in range(ncols):
        pivot = None
        for i in range(r, m):
            if (rows[i] >> col) & 1:
                pivot = i
                break
        if pivot is None:
            continue
        rows[r], rows[pivot] = rows[pivot], rows[r]
        for i in range(m):
            if i != r and ((rows[i] >> col) & 1):
                rows[i] ^= rows[r]
        pivots.append(col)
        r += 1
        if r == m:
            break
    return rows, pivots

def nullspace_basis(rows: List[int], ncols: int) -> List[int]:
    R, pivots = rref_bitrows(rows, ncols)
    pivot_set = set(pivots)
    free_cols = [j for j in range(ncols) if j not in pivot_set]
    out: List[int] = []
    for j in free_cols:
        v = 1 << j
        for ri, pcol in enumerate(pivots):
            if (R[ri] >> j) & 1:
                v |= (1 << pcol)
        out.append(v)
    return out

def words_to_int(words: Tuple[int, ...]) -> int:
    acc = 0
    for w in words:
        acc = (acc << 64) | (w & ((1 << 64) - 1))
    return acc

def int_to_words(x: int, arity: int) -> Tuple[int, ...]:
    mask = (1 << 64) - 1
    out = [0] * arity
    for i in range(arity - 1, -1, -1):
        out[i] = x & mask
        x >>= 64
    return tuple(out)

def reduce_basis(vectors: List[int], nbits: int) -> List[int]:
    piv = [0] * nbits
    for v in vectors:
        x = v
        for b in range(nbits - 1, -1, -1):
            if ((x >> b) & 1) == 0:
                continue
            if piv[b]:
                x ^= piv[b]
            else:
                piv[b] = x
                break
    return [p for p in piv if p]

# ===== Main: parse, constrain (allow j%4 in {0,1}), intersect, print =====

A = parse_tuple_block(INPUT_STR)
arity = len(A[0])
nbits = 64 * arity

# positions to force to zero
forbidden = [j for j in range(nbits) if (j % 4) in (2, 3)]

# Build constraint matrix rows as len(A)-bit integers
M_rows: List[int] = []
for p in forbidden:
    row = 0
    for i, vec in enumerate(A):
        if bit_at(vec, p):
            row |= (1 << i)
    M_rows.append(row)

# Solve M c = 0 (over GF(2))
coeffs = nullspace_basis(M_rows, ncols=len(A))

# Build candidate vectors in V
candidates_ints: List[int] = []
for c in coeffs:
    acc = tuple(0 for _ in range(arity))
    t = c
    while t:
        lsb = t & -t
        idx = lsb.bit_length() - 1
        acc = xor_words(acc, A[idx])
        t ^= lsb
    candidates_ints.append(words_to_int(acc))

# Reduce to a basis of V ∩ W
basis_ints = reduce_basis(candidates_ints, nbits=nbits)

# Sanity check: only j%4 in {0,1}
for x in basis_ints:
    w = int_to_words(x, arity)
    for j in range(nbits):
        if (j % 4) in (2, 3) and bit_at(w, j):
            raise AssertionError("Forbidden bit set in output")

# Print without quotes, like (0x..., 0x..., ...)
print(f"Parsed {len(A)} vectors, arity={arity}, nbits={nbits}")
print(f"Dimension of V∩W: {len(basis_ints)}")
for x in basis_ints:
    words = int_to_words(x, arity)
    inside = ", ".join(f"{w:#018x}" for w in words)
    print(f"({inside})")
