# SageMath: RREF over GF(2) for space-separated tuples with 1, 2, or 3 words (64-bit each)

import re

# ---------- Paste your entire input string between the triple quotes ----------
DATA = r"""
(0x8000000000000000, 0x0000000000000000, 0x0000000000000000)
(0x4000000000000000, 0x0000000000000000, 0x0000000000000000)
(0x2000000000000000, 0x0000000000000000, 0x0000000000000000)
(0x1000000000000000, 0x0000000000000000, 0x0000000000000000)
(0x0800000000000000, 0x0000000000000000, 0x0000000000000000)
(0x0400000000000000, 0x0000000000000000, 0x0000000000000000)
(0x0200000000000000, 0x0000000000000000, 0x0000000000000000)
(0x0100000000000000, 0x0000000000000000, 0x0000000000000000)
(0x0080000000000000, 0x0000000000000000, 0x0000000000000000)
(0x0040000000000000, 0x0000000000000000, 0x0000000000000000)
(0x0020000000000000, 0x0000000000000000, 0x0000000000000000)
(0x0010000000000000, 0x0000000000000000, 0x0000000000000000)
(0x0008000000000000, 0x0000000000000000, 0x0000000000000000)
(0x0004000000000000, 0x0000000000000000, 0x0000000000000000)
(0x0002000000000000, 0x0000000000000000, 0x0000000000000000)
(0x0001000000000000, 0x0000000000000000, 0x0000000000000000)
(0x0000800000000000, 0x0000000000000000, 0x0000000000000000)
(0x0000400000000000, 0x0000000000000000, 0x0000000000000000)
(0x0000200000000000, 0x0000000000000000, 0x0000000000000000)
(0x0000100000000000, 0x0000000000000000, 0x0000000000000000)
(0x0000080000000000, 0x0000000000000000, 0x0000000000000000)
(0x0000040000000000, 0x0000000000000000, 0x0000000000000000)
(0x0000020000000000, 0x0000000000000000, 0x0000000000000000)
(0x0000010000000000, 0x0000000000000000, 0x0000000000000000)
(0x0000008000000000, 0x0000000000000000, 0x0000000000000000)
(0x0000004000000000, 0x0000000000000000, 0x0000000000000000)
(0x0000002000000000, 0x0000000000000000, 0x0000000000000000)
(0x0000001000000000, 0x0000000000000000, 0x0000000000000000)
(0x0000000800000000, 0x0000000000000000, 0x0000000000000000)
(0x0000000400000000, 0x0000000000000000, 0x0000000000000000)
(0x0000000200000000, 0x0000000000000000, 0x0000000000000000)
(0x0000000100000000, 0x0000000000000000, 0x0000000000000000)
(0x0000000080000000, 0x0000000000000000, 0x0000000000000000)
(0x0000000040000000, 0x0000000000000000, 0x0000000000000000)
(0x0000000020000000, 0x0000000000000000, 0x0000000000000000)
(0x0000000010000000, 0x0000000000000000, 0x0000000000000000)
(0x0000000008000000, 0x0000000000000000, 0x0000000000000000)
(0x0000000004000000, 0x0000000000000000, 0x0000000000000000)
(0x0000000002000000, 0x0000020000000000, 0x0000000000000000)
(0x0000000001000000, 0x0000000000000000, 0x0000000000000000)
(0x0000000000800000, 0x0000000000000000, 0x0000000000000000)
(0x0000000000400000, 0x0000000000000000, 0x0000000000000000)
(0x0000000000200000, 0x0000000000000000, 0x0000000000000000)
(0x0000000000080000, 0x0000000000000000, 0x0000000000000000)
(0x0000000000040000, 0x0000000000000000, 0x0000000000000000)
(0x0000000000020000, 0x0000000000000000, 0x0000000000000000)
(0x0000000000010000, 0x0000000000000000, 0x0000000000000000)
(0x0000000000008000, 0x0000000000000000, 0x0000000000000000)
(0x0000000000004000, 0x0000000000000000, 0x0000000000000000)
(0x0000000000002000, 0x0000000000000000, 0x0000000000000000)
(0x0000000000001000, 0x0000000000000000, 0x0000000000000000)
(0x0000000000000400, 0x0000000000000000, 0x0000000000000000)
(0x0000000000000200, 0x0000000000000000, 0x0000000000000000)
(0x0000000000000100, 0x0000000000000000, 0x0000000000000000)
(0x0000000000000080, 0x0000000000000000, 0x0000000000000000)
(0x0000000000000040, 0x0000000000200000, 0x0000000000000000)
(0x0000000000000020, 0x0000000000000000, 0x0000000000000000)
(0x0000000000000010, 0x0000000000000000, 0x0000000000000000)
(0x0000000000000008, 0x0000000000000000, 0x0000000000000000)
(0x0000000000000004, 0x0000000000000000, 0x0000000000000000)
(0x0000000000000002, 0x0000000000000000, 0x0000000000000000)
(0x0000000000000001, 0x0000000000000000, 0x0000000000000000)
(0x0000000000000000, 0x8000000000000000, 0x0000000000000000)
(0x0000000000000000, 0x4000000000000000, 0x0000000000000000)
(0x0000000000000000, 0x2000000000000000, 0x0000000000000000)
(0x0000000000000000, 0x1000000000000000, 0x0000000000000000)
(0x0000000000000000, 0x0800000000000000, 0x0000000000000000)
(0x0000000000000000, 0x0400000000000000, 0x0000000000000000)
(0x0000000000000000, 0x0200000000000000, 0x0000000000000000)
(0x0000000000000000, 0x0100000000000000, 0x0000000000000000)
(0x0000000000000000, 0x0080000000000000, 0x0000000000000000)
(0x0000000000000000, 0x0040000000000000, 0x0000000000000000)
(0x0000000000000000, 0x0020000000000000, 0x0000000000000000)
(0x0000000000000000, 0x0010000000000000, 0x0000000000000000)
(0x0000000000000000, 0x0008000000000000, 0x0000000000000000)
(0x0000000000000000, 0x0004000000000000, 0x0000000000000000)
(0x0000000000000000, 0x0002000000000000, 0x0000000000000000)
(0x0000000000000000, 0x0001000000000000, 0x0000000000000000)
(0x0000000000000000, 0x0000800000000000, 0x0000000000000000)
(0x0000000000000000, 0x0000400000000000, 0x0000000000000000)
(0x0000000000000000, 0x0000200000000000, 0x0000000000000000)
(0x0000000000000000, 0x0000100000000000, 0x0000000000000000)
(0x0000000000000000, 0x0000080000000000, 0x0000000000000000)
(0x0000000000000000, 0x0000040000000000, 0x0000000000000000)
(0x0000000000000000, 0x0000020008400000, 0x0000000000000000)
(0x0000000000000000, 0x0000010000000000, 0x0000000000000000)
(0x0000000000000000, 0x0000008000000000, 0x0000000000000000)
(0x0000000000000000, 0x0000004000000000, 0x0000000000000000)
(0x0000000000000000, 0x0000000800000000, 0x0000000000000000)
(0x0000000000000000, 0x0000000400000000, 0x0000000000000000)
(0x0000000000000000, 0x0000000200000000, 0x0000000000000000)
(0x0000000000000000, 0x0000000080000000, 0x0000000000000000)
(0x0000000000000000, 0x0000000040000000, 0x0000000000000000)
(0x0000000000000000, 0x0000000020000000, 0x0000000000000000)
(0x0000000000000000, 0x0000000010000000, 0x0000000000000000)
(0x0000000000000000, 0x0000000008400000, 0x0200000000000000)
(0x0000000000000000, 0x0000000004000000, 0x0000000000000000)
(0x0000000000000000, 0x0000000001000000, 0x0000000000000000)
(0x0000000000000000, 0x0000000000200004, 0x0000000000000000)
(0x0000000000000000, 0x0000000000080000, 0x0000000000000000)
(0x0000000000000000, 0x0000000000020000, 0x0000000000000000)
(0x0000000000000000, 0x0000000000008000, 0x0000000000000000)
(0x0000000000000000, 0x0000000000004000, 0x0000000000000000)
(0x0000000000000000, 0x0000000000002000, 0x0000000000000000)
(0x0000000000000000, 0x0000000000001000, 0x0000000000000000)
(0x0000000000000000, 0x0000000000000400, 0x0000000000000000)
(0x0000000000000000, 0x0000000000000200, 0x0000000000000000)
(0x0000000000000000, 0x0000000000000100, 0x0000000000000000)
(0x0000000000000000, 0x0000000000000020, 0x0000000000000000)
(0x0000000000000000, 0x0000000000000010, 0x0000000000000000)
(0x0000000000000000, 0x0000000000000008, 0x0000000000000000)
(0x0000000000000000, 0x0000000000000004, 0x0000000000020000)
(0x0000000000000000, 0x0000000000000002, 0x0000000000000000)
(0x0000000000000000, 0x0000000000000001, 0x0000000000000000)
(0x0000000000000000, 0x0000000000000000, 0x8000000000000000)
(0x0000000000000000, 0x0000000000000000, 0x4000000000020000)
(0x0000000000000000, 0x0000000000000000, 0x2000000000000000)
(0x0000000000000000, 0x0000000000000000, 0x1000000000000000)
(0x0000000000000000, 0x0000000000000000, 0x0800000000000000)
(0x0000000000000000, 0x0000000000000000, 0x0400000000000000)
(0x0000000000000000, 0x0000000000000000, 0x0200084000000000)
(0x0000000000000000, 0x0000000000000000, 0x0100000000000000)
(0x0000000000000000, 0x0000000000000000, 0x0080000000000000)
(0x0000000000000000, 0x0000000000000000, 0x0040000000000000)
(0x0000000000000000, 0x0000000000000000, 0x0008000000000000)
(0x0000000000000000, 0x0000000000000000, 0x0004000000000000)
(0x0000000000000000, 0x0000000000000000, 0x0000800000000000)
(0x0000000000000000, 0x0000000000000000, 0x0000400000000000)
(0x0000000000000000, 0x0000000000000000, 0x0000200000000000)
(0x0000000000000000, 0x0000000000000000, 0x0000040000000000)
(0x0000000000000000, 0x0000000000000000, 0x0000010000000000)
(0x0000000000000000, 0x0000000000000000, 0x0000000080000000)
(0x0000000000000000, 0x0000000000000000, 0x0000000020000000)
(0x0000000000000000, 0x0000000000000000, 0x0000000004000000)
(0x0000000000000000, 0x0000000000000000, 0x0000000001000000)
(0x0000000000000000, 0x0000000000000000, 0x0000000000008000)
(0x0000000000000000, 0x0000000000000000, 0x0000000000002000)
(0x0000000000000000, 0x0000000000000000, 0x0000000000000400)
(0x0000000000000000, 0x0000000000000000, 0x0000000000000200)
(0x0000000000000000, 0x0000000000000000, 0x0000000000000100)
(0x0000000000000000, 0x0000000000000000, 0x0000000000000020)
(0x0000000000000000, 0x0000000000000000, 0x0000000000000010)
(0x0000000000000000, 0x0000000000000000, 0x0000000000000002)
(0x0000000000000000, 0x0000000000000000, 0x0000000000000001)
"""
# -----------------------------------------------------------------------------


WORD_BITS = 64         # change if your words arenâ€™t 64-bit
HEX_WIDTH = (WORD_BITS + 3) // 4  # digits to print (64 -> 16)

def clean_input(s: str) -> str:
    # Be tolerant of a few stray characters seen in some logs.
    s = s.replace('`', '')
    s = s.replace('x`0x', '0x')
    return s

def parse_tuples_1to3(s: str):
    """
    Accepts a single string like:
      (0x..., 0x...) (0x...) (0x..., 0x..., 0x...)   # tuples separated by spaces
    Returns a list of tuples of ints. All tuples must have the same length (1..3).
    """
    s = clean_input(s)
    # Grab the inside of each (...) allowing 1..3 comma-separated ints (hex or dec)
    pat = re.compile(
        r'\(\s*((?:0x[0-9a-fA-F]+|\d+)(?:\s*,\s*(?:0x[0-9a-fA-F]+|\d+)){0,2})\s*\)'
    )
    triples = []
    for inner in pat.findall(s):
        words = [w.strip() for w in inner.split(',')]
        tup = tuple(int(w, 0) for w in words)  # base=0 supports 0x... and decimal
        if not (1 <= len(tup) <= 3):
            raise ValueError("Only 1-, 2-, or 3-element tuples are supported.")
        triples.append(tup)

    if not triples:
        raise ValueError("No tuples found. Make sure they look like (0x..., 0x...).")

    arities = {len(t) for t in triples}
    if len(arities) != 1:
        raise ValueError(f"Inconsistent tuple sizes found: {sorted(arities)}. "
                         f"Please use a single arity (all 1-elem, all 2-elem, or all 3-elem).")
    return triples, next(iter(arities))

def to_bits_msb(x, n=64, *, strict=True):
    x = Integer(x)
    if strict and x.bit_length() > n:
        raise ValueError(f"value 0x{int(x):x} exceeds {n} bits")
    x &= (1 << n) - 1
    return [int((x >> (n-1-i)) & 1) for i in range(n)]

def bits_to_int(bits):
    v = 0
    for b in bits:
        v = (v << 1) | int(b)
    return Integer(v)

def tuples_to_matrix_hex(tuples_list, num_words, word_bits):
    rows = []
    for tup in tuples_list:
        if len(tup) != num_words:
            raise ValueError("All tuples must have the same length.")
        row_bits = []
        for w in tup:
            row_bits.extend(to_bits_msb(w, word_bits))
        rows.append(row_bits)
    return Matrix(GF(2), rows)

def rref_and_pivots(M):
    # Prefer true RREF; fall back to echelon if needed.
    try:
        R = M.rref()
    except Exception:
        R = M.echelon_form()
    # Derive pivot columns from first 1 in each nonzero row (works for RREF).
    pivots = []
    for i in range(R.nrows()):
        row = R[i]
        if any(row[j] == 1 for j in range(R.ncols())):
            for j in range(R.ncols()):
                if row[j] == 1:
                    pivots.append(j)
                    break
    return R, tuple(pivots)

def rref_from_string(s, word_bits=64):
    vecs, num_words = parse_tuples_1to3(s)
    M = tuples_to_matrix_hex(vecs, num_words, word_bits)
    R, piv = rref_and_pivots(M)

    # Convert nonzero rows of R back to tuples
    out = []
    for i in range(R.nrows()):
        if any(R[i, j] == 1 for j in range(R.ncols())):
            row_bits = [int(b) for b in R[i]]
            words = []
            for k in range(num_words):
                chunk = row_bits[k*word_bits:(k+1)*word_bits]
                words.append(bits_to_int(chunk))
            out.append(tuple(words))
    return M, R, piv, out, num_words

# ---- Run ----
M, R, pivots, rref_tuples, NUM_WORDS = rref_from_string(DATA, WORD_BITS)

print(f"Parsed rows: {M.nrows()}   Tuple arity: {NUM_WORDS}")
print(f"Rank over GF(2): {R.rank()}")
print("Pivot columns:", pivots)

def fmt_tuple(t):
    return "(" + ", ".join(f"0x{int(w):0{HEX_WIDTH}x}" for w in t) + ")"

print("\nRREF rows (one per line):")
for t in rref_tuples:
    print(fmt_tuple(t))

print("\nRREF rows (single-line):")
print(" ".join(fmt_tuple(t) for t in rref_tuples))
